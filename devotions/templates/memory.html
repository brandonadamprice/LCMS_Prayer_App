{% extends "base.html" %}
{% import "_macros.html" as macros %}

{% block title %}Scripture Memorization{% endblock %}

{% block content %}
<div class="page-header">
  <h1>Scripture Memorization</h1>
  <p>Select a verse below to begin memorizing.</p>
</div>

<div class="card">
  <h2>Select Verse</h2>
  <select
    id="verse-select"
    style="
      width: 100%;
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      box-sizing: border-box;
      margin-bottom: 10px;
    "
  >
    <option value="-1">-- Select a verse --</option>
  </select>
</div>

<div class="card">
  <h2>Memorization Drill</h2>
  <p class="ref" id="drill-ref"></p>
  <div
    id="drill-text"
    style="
      min-height: 50px;
      margin-bottom: 15px;
      font-size: 1.1em;
      line-height: 1.8;
    "
  >
    Select a verse above to start.
  </div>
  <button class="button" id="btn-reset" disabled>Reset</button>
  <button class="button" id="btn-fill-blank" disabled>Fill-in-the-Blank</button>
  <button class="button" id="btn-first-letter" disabled>First Letters</button>
  <button class="button" id="btn-word-order" disabled>Word Order</button>
  
  {% if current_user.is_authenticated %}
  <hr style="margin: 20px 0;">
  <div style="text-align: center;">
      <button id="btn-mark-memorized" class="button" style="background-color: #f39c12; font-size: 1.1em; display: none;" onclick="toggleMemorized()">
          Mark as Memorized
      </button>
  </div>
  {% endif %}
</div>

{% if current_user.is_authenticated %}
<div class="card">
  <h2>My Memory Verses</h2>
  <p>Add or remove your own verses to memorize.</p>
  <form action="/add_memory_verse" method="post" style="margin-bottom: 20px">
    <div style="margin-bottom: 10px">
      <label for="ref">Verse Reference (e.g., John 3:16):</label><br />
      <input
        type="text"
        id="ref"
        name="ref"
        required
        style="
          width: 100%;
          padding: 8px;
          border-radius: 4px;
          border: 1px solid #ccc;
          box-sizing: border-box;
        "
      />
    </div>
    <div style="margin-bottom: 10px">
      <label for="topic">Topic (Optional):</label><br />
      <input
        type="text"
        id="topic"
        name="topic"
        style="
          width: 100%;
          padding: 8px;
          border-radius: 4px;
          border: 1px solid #ccc;
          box-sizing: border-box;
        "
      />
    </div>
    <button type="submit" class="button">Add Verse</button>
  </form>
  <div id="user-verses-list"></div>
</div>
{% else %}
<div class="card">
    <h2>My Memory Verses</h2>
    <p>Log in via the menu (â˜°) to add and manage your own memory verses.</p>
</div>
{% endif %}
{% endblock %}

{% block extra_js %}
const verses = {{ verses|tojson }};
const verseSelect = document.getElementById('verse-select');
const drillRef = document.getElementById('drill-ref');
const drillText = document.getElementById('drill-text');
const btnFillBlank = document.getElementById('btn-fill-blank');
const btnFirstLetter = document.getElementById('btn-first-letter');
const btnWordOrder = document.getElementById('btn-word-order');
const btnReset = document.getElementById('btn-reset');
const userVersesList = document.getElementById('user-verses-list');
const btnMarkMemorized = document.getElementById('btn-mark-memorized');

let currentVerseIndex = -1;
let currentCleanText = "";
let currentHtmlText = "";
let currentVerseId = null;
let currentVerseMemorized = false;
let wordOrderCorrectList = [];
let wordOrderCurrentIndex = 0;

function populateVerseSelect() {
    let groupPredefined = document.createElement('optgroup');
    groupPredefined.label = 'Predefined Verses';
    let groupUser = document.createElement('optgroup');
    groupUser.label = 'My Verses';

    verses.forEach((verse, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = `${verse.ref} - ${verse.topic}`;
        if (verse.is_user) {
            groupUser.appendChild(option);
        } else {
            groupPredefined.appendChild(option);
        }
    });

    if (groupPredefined.hasChildNodes()) {
      verseSelect.appendChild(groupPredefined);
    }
    if (groupUser.hasChildNodes()) {
      verseSelect.appendChild(groupUser);
    }
}

function populateUserVerseList() {
    if (!userVersesList) return;
    const userVerses = verses.filter(v => v.is_user);
    if (userVerses.length === 0) {
        userVersesList.innerHTML = '<p><em>You have not added any verses yet.</em></p>';
        return;
    }
    let html = '<ul style="list-style: none; padding: 0;">';
    userVerses.forEach(verse => {
        html += `
            <li style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #eee; padding: 5px 0;">
                <span>${verse.ref} - ${verse.topic}</span>
                <form action="/delete_memory_verse" method="post" style="margin: 0;">
                    <input type="hidden" name="verse_id" value="${verse.id}">
                    <button type="submit" class="button" style="background-color: #e74c3c; padding: 3px 8px; font-size: 0.8em; margin: 0;">Delete</button>
                </form>
            </li>
        `;
    });
    html += '</ul>';
    userVersesList.innerHTML = html;
}

function setDrillButtonsEnabled(enabled) {
    btnFillBlank.disabled = !enabled;
    btnFirstLetter.disabled = !enabled;
    btnWordOrder.disabled = !enabled;
    btnReset.disabled = !enabled;
}

function loadVerse(index) {
    currentVerseIndex = index;
    if (index === -1) {
        drillRef.textContent = '';
        drillText.innerHTML = 'Select a verse above to start.';
        currentCleanText = "";
        currentHtmlText = "";
        setDrillButtonsEnabled(false);
        if(btnMarkMemorized) btnMarkMemorized.style.display = 'none';
    } else {
        const verse = verses[index];
        drillRef.textContent = verse.ref;
        drillText.innerHTML = verse.text_html;
        currentCleanText = verse.clean_text;
        currentHtmlText = verse.text_html;
        currentVerseId = verse.id;
        currentVerseMemorized = verse.is_memorized;
        
        setDrillButtonsEnabled(true);
        updateMemorizedButton();
    }
}

function updateMemorizedButton() {
    if(!btnMarkMemorized) return;
    btnMarkMemorized.style.display = 'inline-block';
    if(currentVerseMemorized) {
        btnMarkMemorized.innerHTML = '<span style="margin-right: 5px;">ðŸ§ </span> Memorized (Tap to undo)';
        btnMarkMemorized.style.backgroundColor = "#27ae60";
    } else {
        btnMarkMemorized.innerHTML = 'Mark as Memorized';
        btnMarkMemorized.style.backgroundColor = "#f39c12";
    }
}

async function toggleMemorized() {
    if(!currentVerseId) return;
    
    // Optimistic UI update
    currentVerseMemorized = !currentVerseMemorized;
    updateMemorizedButton();
    // Update data array
    if(verses[currentVerseIndex]) {
        verses[currentVerseIndex].is_memorized = currentVerseMemorized;
    }

    try {
        const response = await fetch('/api/toggle_memorized_verse', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ verse_id: currentVerseId })
        });
        const data = await response.json();
        
        if (data.milestone_reached) {
             if (window.triggerMilestoneModal) {
                 window.triggerMilestoneModal(data.milestone_msg, data.count);
            } else {
                 alert(data.milestone_msg);
            }
        }
    } catch (e) {
        console.error("Error toggling memorized:", e);
        // Revert
        currentVerseMemorized = !currentVerseMemorized;
        updateMemorizedButton();
        if(verses[currentVerseIndex]) {
            verses[currentVerseIndex].is_memorized = currentVerseMemorized;
        }
    }
}

function resetVerse() {
    if (currentVerseIndex !== -1) {
        drillText.innerHTML = currentHtmlText;
    }
}

function triggerFireworks(bursts = 4, particlesPerBurst = 25) {
    const colors = ['#FFC107', '#FF5722', '#4CAF50', '#2196F3', '#9C27B0', '#F44336', '#00BCD4'];
    const createParticle = (x, y) => {
        const particle = document.createElement('div');
        particle.classList.add('particle');
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        particle.style.background = colors[Math.floor(Math.random() * colors.length)];
        const angle = Math.random() * 360;
        const distance = Math.random() * 120 + 50; // 50-170px burst radius
        particle.style.setProperty('--dx', `${Math.cos(angle * Math.PI / 180) * distance}px`);
        particle.style.setProperty('--dy', `${Math.sin(angle * Math.PI / 180) * distance}px`);
        document.body.appendChild(particle);
        setTimeout(() => particle.remove(), 1200); // give animation time
    };

    for(let i = 0; i < bursts; i++) {
        setTimeout(() => {
            const burstX = Math.random() * (window.innerWidth * 0.8) + (window.innerWidth * 0.1); // 10%-90% width
            const burstY = Math.random() * (window.innerHeight * 0.7) + (window.innerHeight * 0.1); // 10%-80% height
            for(let j = 0; j < particlesPerBurst; j++) {
                createParticle(burstX, burstY);
            }
        }, i * 150); // Stagger bursts
    }
}

function checkAnswer(event) {
    const input = event.target;
    const answer = input.dataset.answer.toLowerCase();
    const value = input.value.toLowerCase();

    if (value === '') {
        input.classList.remove('wrong');
        input.classList.remove('correct');
    } else if (answer === value) {
        input.classList.remove('wrong');
        input.classList.add('correct');
        const inputs = drillText.querySelectorAll('.memory-input');
        const currentIndex = Array.from(inputs).indexOf(input);
        if (currentIndex > -1 && currentIndex < inputs.length - 1) {
            inputs[currentIndex + 1].focus();
        } else if (currentIndex === inputs.length - 1) {
            // Last input was correct
             if (Array.from(inputs).every(i => i.classList.contains('correct'))) {
                triggerFireworks();
            }
        }
    } else if (answer.startsWith(value)) {
        input.classList.remove('wrong');
        input.classList.remove('correct');
    } else {
        input.classList.add('wrong');
        input.classList.remove('correct');
    }
}

function createDrill(isFirstLetter) {
    if (!currentCleanText) return;
    drillText.innerHTML = ''; // Clear
    const words = currentCleanText.split(/([,\.\?!;:" ]+)/); // Split by punctuation/space, keeping delimiters

    words.forEach(word => {
        const shouldBeBlank = isFirstLetter ? true : Math.random() < 0.3;
        if (word.match(/^\w+$/) && shouldBeBlank) {
            const input = document.createElement('input');
            input.type = 'text';
            input.classList.add('memory-input');
            input.dataset.answer = word;
            input.style.width = `${word.length + 1}ch`;
            if(isFirstLetter) {
                input.placeholder = word.charAt(0);
            }
            input.addEventListener('input', checkAnswer);
            drillText.appendChild(input);
        } else {
            drillText.appendChild(document.createTextNode(word));
        }
    });
}

function fillInTheBlank() {
    createDrill(false);
}

function firstLetters() {
    createDrill(true);
}

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

function onWordBankClick(event) {
    const btn = event.target;
    if (btn.textContent === wordOrderCorrectList[wordOrderCurrentIndex]) {
        const built = document.getElementById('built-sentence');
        built.textContent += btn.textContent + ' ';
        btn.disabled = true;
        wordOrderCurrentIndex++;
        if(wordOrderCurrentIndex === wordOrderCorrectList.length) {
            triggerFireworks();
        }
    } else {
        btn.classList.add('wrong');
        setTimeout(() => btn.classList.remove('wrong'), 500);
    }
}

function wordOrder() {
    if (!currentCleanText) return;
    wordOrderCorrectList = currentCleanText.match(/[\w']+|[^\w\s']/g); // split into words and punctuation
    wordOrderCorrectList = currentCleanText.split(/(\s+)/).filter(w => w.trim().length > 0);


    wordOrderCorrectList = currentCleanText.split(' ').filter(w => w);
    wordOrderCurrentIndex = 0;
    const shuffled = shuffle([...wordOrderCorrectList]);

    drillText.innerHTML = `<div id="built-sentence"></div><div id="word-bank" style="margin-top:15px; border-top: 1px solid #eee; padding-top: 10px;"></div>`;
    const bank = document.getElementById('word-bank');
    shuffled.forEach(word => {
        const btn = document.createElement('button');
        btn.className = 'button';
        btn.textContent = word;
        btn.onclick = onWordBankClick;
        bank.appendChild(btn);
    });
}

verseSelect.addEventListener('change', (e) => {
    loadVerse(parseInt(e.target.value, 10));
});

btnFillBlank.addEventListener('click', () => fillInTheBlank());
btnFirstLetter.addEventListener('click', () => firstLetters());
btnWordOrder.addEventListener('click', () => wordOrder());
btnReset.addEventListener('click', () => resetVerse());

document.addEventListener('DOMContentLoaded', () => {
    populateVerseSelect();
    populateUserVerseList();
    loadVerse(-1);
});

{% endblock %}
